// Generated by CoffeeScript 2.0.3
(function() {
  var ALARM_NAME, BLINK_INTERVAL, BLINK_LIMIT, Chromagochi, LIFE_MINUTES, MAX_HUE, NAME, Pet, STORAGE_KEY, TICK_MINUTES, cg, hsl2rgb, intervals, timeSince;

  TICK_MINUTES = 1;

  ALARM_NAME = 'tick';

  STORAGE_KEY = 'chromagochi';

  LIFE_MINUTES = 120;

  BLINK_INTERVAL = 300;

  BLINK_LIMIT = 30;

  MAX_HUE = 359;

  NAME = 'Chromagochi';

  // http://jsfiddle.net/EPWF6/9/
  hsl2rgb = function(H, S, L) {
    var B, B1, C, G, G1, H_, R, R1, X, m;
    // calculate chroma
    C = (1 - Math.abs((2 * L) - 1)) * S;
    // Find a point (R1, G1, B1) along the bottom three faces of the RGB cube, with the same hue and chroma as our color (using the intermediate value X for the second largest component of this color)
    H_ = H / 60;
    X = C * (1 - Math.abs((H_ % 2) - 1));
    if (H === void 0 || isNaN(H) || H === null) {
      R1 = G1 = B1 = 0;
    } else {
      if (H_ >= 0 && H_ < 1) {
        R1 = C;
        G1 = X;
        B1 = 0;
      } else if (H_ >= 1 && H_ < 2) {
        R1 = X;
        G1 = C;
        B1 = 0;
      } else if (H_ >= 2 && H_ < 3) {
        R1 = 0;
        G1 = C;
        B1 = X;
      } else if (H_ >= 3 && H_ < 4) {
        R1 = 0;
        G1 = X;
        B1 = C;
      } else if (H_ >= 4 && H_ < 5) {
        R1 = X;
        G1 = 0;
        B1 = C;
      } else if (H_ >= 5 && H_ < 6) {
        R1 = C;
        G1 = 0;
        B1 = X;
      }
    }
    // Find R, G, and B by adding the same amount to each component, to match lightness
    m = L - (C / 2);
    // Normalise to range [0,255] by multiplying 255
    R = (R1 + m) * 255;
    G = (G1 + m) * 255;
    B = (B1 + m) * 255;
    R = Math.round(R);
    G = Math.round(G);
    B = Math.round(B);
    return {
      R: R,
      G: G,
      B: B
    };
  };

  intervals = [
    {
      label: 'year',
      seconds: 31536000
    },
    {
      label: 'month',
      seconds: 2592000
    },
    {
      label: 'day',
      seconds: 86400
    },
    {
      label: 'hour',
      seconds: 3600
    },
    {
      label: 'minute',
      seconds: 60
    },
    {
      label: 'second',
      seconds: 1
    }
  ];

  timeSince = function(date) {
    var count, ending, interval, seconds;
    seconds = Math.floor((Date.now() - date.getTime()) / 1000);
    interval = intervals.find(function(i) {
      return i.seconds <= seconds;
    });
    count = Math.floor(seconds / interval.seconds);
    ending = 's';
    if (count === 1) {
      ending = '';
    }
    return count + ' ' + interval.label + ending;
  };

  Pet = (function() {
    class Pet {
      constructor(callback) {
        var self;
        this.feed = this.feed.bind(this);
        this.age = this.age.bind(this);
        this.update = this.update.bind(this);
        this.load = this.load.bind(this);
        this.startBlinking = this.startBlinking.bind(this);
        this.stopBlinking = this.stopBlinking.bind(this);
        self = this;
        this.load(function() {
          if (callback != null) {
            callback();
          }
          return self.update();
        });
      }

      isAlive() {
        return this.status.happiness > 0;
      }

      feed() {
        window._gaq.push(['_trackEvent', this.status.happiness, 'feed']);
        if (!this.isAlive()) {
          this.status.born = new Date().getTime() - 1000;
        }
        if (this.status.happiness !== this.default.happiness) {
          this.status.feed_times = (this.status.feed_times || 0) + 1;
          window._gaq.push(['_trackEvent', this.status.feed_times, 'feed']);
        }
        this.status.happiness = this.default.happiness;
        this.save();
        this.stopBlinking();
        return this.update();
      }

      age(minutes) {
        this.status.happiness--;
        if (this.status.happiness === 0) {
          this.status.dead_times = (this.status.dead_times || 0) + 1;
          window._gaq.push(['_trackEvent', this.status.dead_times, 'dead']);
        }
        this.save();
        this.update();
        if (this.status.happiness === BLINK_LIMIT) {
          return this.startBlinking();
        }
      }

      update() {
        var c, h;
        chrome.browserAction.setBadgeText({
          text: this.status.happiness + ''
        });
        if (this.blinker == null) {
          //l = 1-1/(1.3+@status.happiness/5)
          //c = hsl2rgb 0, 1, l
          h = Math.round(((this.status.happiness - BLINK_LIMIT) / (LIFE_MINUTES - BLINK_LIMIT)) * MAX_HUE);
          h = (30 + h) % MAX_HUE;
          c = hsl2rgb(h, 1, 0.8);
          this._setColor([c.R, c.G, c.B, 255]);
        }
        return chrome.browserAction.setTitle({
          title: NAME + " #" + (this.status.dead_times + 1) + "\n" + "Born: " + timeSince(new Date(this.status.born)) + " ago"
        });
      }

      clone(object) {
        return JSON.parse(JSON.stringify(object));
      }

      load(callback) {
        var self;
        self = this;
        chrome.storage.local.get(STORAGE_KEY, function(items) {
          self.status = items[STORAGE_KEY] || self.clone(self.default);
          if (!self.status.dead_times) {
            self.status.dead_times = 0;
          }
          if (!self.status.born) {
            self.status.born = new Date().getTime();
          }
          if (callback != null) {
            return callback();
          }
        });
        return true;
      }

      save(callback) {
        var data;
        data = {};
        if (!this.status.born) {
          this.status.born = new Date().getTime();
        }
        if (!this.dead_times) {
          this.dead_times = 0;
        }
        data[STORAGE_KEY] = this.status;
        return chrome.storage.local.set(data, function() {
          if (callback != null) {
            return callback();
          }
        });
      }

      _setColor(color) {
        chrome.browserAction.setBadgeBackgroundColor({
          color: color
        });
        return true;
      }

      startBlinking() {
        var self, toggle;
        self = this;
        toggle = false;
        return this.blinker = setInterval(function() {
          var color;
          color = [0, 0, 0, 255];
          if (toggle) {
            color = [255, 0, 0, 255];
          }
          self._setColor(color);
          return toggle = !toggle;
        }, BLINK_INTERVAL);
      }

      stopBlinking() {
        if (this.blinker != null) {
          clearInterval(this.blinker);
        }
        this.blinker = null;
        return true;
      }

    };

    Pet.prototype.default = {
      name: 'Chromagochi',
      happiness: LIFE_MINUTES,
      dead_times: 0,
      feed_times: 0,
      born: new Date().getTime()
    };

    Pet.prototype.blinker = null;

    Pet.prototype.status = null;

    return Pet;

  })();

  Chromagochi = (function() {
    class Chromagochi {
      constructor() {
        var self;
        this.processAlarm = this.processAlarm.bind(this);
        self = this;
        this.pet = new Pet(null);
        chrome.browserAction.onClicked.addListener(function(tab) {
          return self.pet.feed();
        });
        chrome.alarms.onAlarm.addListener(this.processAlarm);
        true;
      }

      start() {
        chrome.alarms.create(ALARM_NAME, {
          periodInMinutes: TICK_MINUTES
        });
        return true;
      }

      stop() {
        chrome.alarms.clear(ALARM_NAME);
        return true;
      }

      processAlarm(alarm) {
        if (alarm.name === ALARM_NAME) {
          if (this.pet.isAlive()) {
            return this.pet.age(alarm.periodInMinutes);
          }
        }
      }

    };

    Chromagochi.prototype.pet = null;

    return Chromagochi;

  })();

  (function(global) {
    global._gaq = global._gaq || [];
    global._gaq.push(['_setAccount', 'UA-115818-75']);
    global._gaq.push(['_trackPageview']);
    return (function() {
      var ga, s;
      ga = document.createElement("script");
      ga.type = "text/javascript";
      ga.async = true;
      ga.src = "https://ssl.google-analytics.com/ga.js";
      s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(ga, s);
    })();
  })(window);

  cg = new Chromagochi;

  cg.start();

}).call(this);
